<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="license" content="CC BY-NC-SA 4.0" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Why Superconducting Qubits Need Anharmonicity</title>
<style>
  :root { --maxw: 980px; }

  body{
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    margin:0; background:#fff; color:#111;
  }

  /* Title + summary (match cryo page) */
  h1{ text-align:center; font-size:26px; margin:16px 0 4px; }
  #summary{ text-align:center; font-size:18px; font-weight:600; margin:0 0 8px; }

  /* Canvas block */
  #wrap{ position:relative; padding:0 12px 8px; }
  canvas{
    width:100%;
    max-width: calc(var(--maxw) + 260px);
    aspect-ratio: 11 / 4;
    height:auto;
    display:block;
    margin:6px auto 4px;
  }

  /* Controls card (centered) */
  #controls{
    background:#f8fafc; border:1px solid #e5e7eb; border-radius:12px;
    box-shadow:0 3px 10px rgba(0,0,0,.04);
    padding:12px 16px; max-width:calc(var(--maxw));
    margin:12px auto 10px;
    display:flex; flex-direction:column; align-items:center;
    gap:10px;
  }
  .row{
    display:flex; justify-content:center; align-items:center;
    gap:28px; flex-wrap:wrap; width:100%;
  }
  .group{ display:flex; align-items:center; gap:8px; }
  .group output{ width:70px; text-align:right; font-variant-numeric:tabular-nums; }
  .group input[type="range"]{ width:240px; accent-color:#64748b; }

  /* Pill for the drive action */
  .pill{
    background:#fff; border:1px solid #e5e7eb; border-radius:12px;
    box-shadow:0 2px 6px rgba(0,0,0,.03);
    padding:10px 12px; max-width:820px; width:60%;
    display:flex; align-items:center; justify-content:center; gap:12px;
    text-align:center;
  }
  #excite{
    background:#e74c3c; color:#fff; border:none; padding:8px 14px;
    border-radius:8px; font-weight:600; cursor:pointer;
  }
  #excite:disabled{ opacity:.6; cursor:default; }

  /* Legend (same style as cryo) */
  .legend{
    max-width: calc(var(--maxw));
    margin:6px auto 10px;
    background:rgba(255,255,255,0.95);
    border:1px solid #ddd; border-radius:6px;
    padding:8px 12px; font-size:16px;
    box-shadow:0 1px 2px rgba(0,0,0,.05);
  }
  .legend .row{ display:flex; align-items:flex-start; flex-wrap:wrap; gap:8px; margin:4px 0; white-space:normal; }
  .dot{ width:14px; height:14px; border-radius:50%; display:inline-block; }
  .dot.blue{ background:#1f77b4; }
  .dot.red{ background:#d62728; }
  .swatch{ width:24px; height:3px; background:#c0c0c0; display:inline-block; }

  /* Footer license */
  footer{
    text-align:center; font-size:14px; color:#555;
    margin:24px 0 10px; line-height:1.4;
  }
  footer a{ color:#007acc; text-decoration:none; font-weight:500; }
  footer a:hover{ text-decoration:underline; }
</style>
</head>
<body>
  <h1>Why Superconducting Qubits Need Anharmonicity</h1>
  <div id="summary">α = −200 MHz · Drive = 5.00 GHz · Pulse BW ≈ 22.7 MHz</div>

  <div id="wrap">
    <canvas id="ladder"></canvas>
  </div>

  <div id="controls">
    <div class="row">
      <div class="group">
        <label for="alpha">α (MHz)</label>
        <input id="alpha" type="range" min="-400" max="400" step="100" value="0" />
        <output id="alphaVal">0</output>
      </div>
    </div>
    <div class="pill">
      <button id="excite">Excite</button>
      <span>Apply a 5&nbsp;GHz drive pulse (π-like, finite bandwidth)</span>
    </div>
  </div>

  <div class="legend">
    <div class="row"><span class="dot blue"></span> Blue: qubit initially in |0⟩ (ground)</div>
    <div class="row"><span class="dot red"></span> Red: qubit initially in |1⟩ (excited)</div>
    <div class="row"><span class="swatch"></span>&nbsp;5&nbsp;GHz external drive (dashed sinusoids)</div>
  </div>

<script>
(() => {
  // ---------- Parameters ----------
  const F01 = 5e9;                 // Hz
  const DRIVE = 5e9;               // Hz (drive center)
  const SIGMA_F = 22.7e6;          // ~Gaussian spectral half-width (Hz)
  const N_LADDER = 4;              // |0>..|3>
  const X_BLUE = 0.30, X_RED = 0.70;

  // ---------- DOM ----------
  const canvas = document.getElementById('ladder');
  const ctx = canvas.getContext('2d');
  const alphaSlider = document.getElementById('alpha');
  const alphaVal = document.getElementById('alphaVal');
  const summary = document.getElementById('summary');
  const exciteBtn = document.getElementById('excite');

  // Responsive bitmap
  function resizeCanvasToDisplaySize(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const needW = Math.round(rect.width  * dpr);
    const needH = Math.round(rect.height * dpr);
    if (canvas.width !== needW || canvas.height !== needH) {
      canvas.width = needW; canvas.height = needH;
    }
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  function layout(){
    const rect = canvas.getBoundingClientRect();
    const cssW = rect.width, cssH = rect.height;
    return {
      left:80, right: cssW-310, top: 90, bottom: cssH-20,
      xArrow: cssW-230
    };
  }

  // ---------- State ----------
  const state = {
    alphaMHz: parseFloat(alphaSlider.value),
    busy: false,
    levelBlue: 0,   // blue starts at |0>
    levelRed: 1     // red  starts at |1>
  };

  // ---------- Physics helpers ----------
  function levels(alphaMHz){
    const alpha = alphaMHz*1e6;
    const En = [], fnn1 = [];
    for (let n=0;n<N_LADDER;n++){
      En.push(F01*n + 0.5*alpha*n*(n-1));  // Hz
      if (n < N_LADDER-1) fnn1.push(F01 + alpha*n);
    }
    return {En, fnn1};
  }
  const ghz = f => (f/1e9).toFixed(2)+"GHz";
  const probGauss = (detuneHz) => Math.exp(-0.5 * (detuneHz/SIGMA_F)**2);

  // ---------- Drawing ----------
  function draw(capsuleFlash=null, leakageFlash=false){
    resizeCanvasToDisplaySize();
    const {left,right,top,bottom,xArrow} = layout();
    const {En, fnn1} = levels(state.alphaMHz);

    const yMin = En[0]-0.3e9, yMax = En[N_LADDER-1]+1.0e9;
    const yScale = y => bottom - (y - yMin) * ((bottom-top)/(yMax-yMin));

    // Clear
    ctx.fillStyle="#fff"; ctx.fillRect(0,0,canvas.width,canvas.height);

    // Status capsule (harmonicity feels)
    const absA = Math.abs(state.alphaMHz);
    const capsuleMsg =
        (absA < 40)  ? "Harmonic vibes — f₀₁ ≈ f₁₂, leakage city 🚨"
      :               "Anharmonicity checked — π pulses stay on 0↔1 ✅";
    const capsuleColor =
        (absA < 40)  ? "rgba(240, 90, 90, .85)"   // red
      :               "rgba(102, 204, 153, .85)"; // green

    ctx.save();
    ctx.font="18px system-ui, sans-serif"; ctx.textAlign="center"; ctx.textBaseline="middle";
    const xMid=(left+right)/2, yMsg=top-30, w=ctx.measureText(capsuleMsg).width, padX=14;
    ctx.fillStyle=capsuleColor; ctx.strokeStyle="rgba(0,0,0,.15)"; ctx.lineWidth=1.2;
    ctx.beginPath(); ctx.roundRect(xMid-w/2-padX, yMsg-14, w+padX*2, 28, 12); ctx.fill(); ctx.stroke();
    ctx.fillStyle="#222"; ctx.fillText(capsuleMsg, xMid, yMsg);
    ctx.restore();

    // Rungs + |n⟩ labels
    ctx.strokeStyle="#000"; ctx.lineWidth=3; ctx.fillStyle="#000"; ctx.font="32px system-ui,sans-serif";
    for (let i=0;i<N_LADDER;i++){
      const y=yScale(En[i]); ctx.beginPath(); ctx.moveTo(left,y); ctx.lineTo(right,y); ctx.stroke();
      ctx.fillText("|"+i+">", right+10, y+11);
    }

    // Dashed vertical arrows with labels f_01, f_12, f_23
    ctx.save(); ctx.setLineDash([6,5]); ctx.strokeStyle="#c0c0c0"; ctx.lineWidth=2;
    ctx.fillStyle="#c0c0c0"; ctx.font="24px system-ui, sans-serif";
    for (let i=0;i<N_LADDER-1;i++){
      const yA=yScale(En[i]), yB=yScale(En[i+1]);
      ctx.beginPath(); ctx.moveTo(xArrow,yA); ctx.lineTo(xArrow,yB); ctx.stroke();
      drawArrowHead(xArrow,yA,-Math.PI); drawArrowHead(xArrow,yB,0);
      const label=`f_${i}${i+1}=${ghz(fnn1[i])}`;
      const lx=xArrow+18, ly=(yA+yB)/2+10;
      // optionally highlight during flash
      if (capsuleFlash && (i===0 || (state.alphaMHz===0 && (i===1||i===2)))) {
        ctx.save(); ctx.fillStyle="green"; ctx.fillText(label,lx,ly); ctx.restore();
      } else {
        ctx.fillText(label,lx,ly);
      }
    }
    ctx.restore();

    // Computational space box (|0>,|1>)
    const y0=yScale(En[0]), y1=yScale(En[1]);
    ctx.save(); ctx.setLineDash([3,3]); ctx.lineWidth=1; ctx.strokeStyle="#000";
    const m=6, boxTop=y1-0.12*Math.abs(y1-y0), boxBot=y0+0.12*Math.abs(y1-y0);
    ctx.strokeRect(left-m,boxTop,(right-left)+2*m,boxBot-boxTop);
    ctx.fillStyle="#000"; ctx.font="16px system-ui, sans-serif";
    ctx.fillText("Computational space", right-160, boxTop+30);
    ctx.restore();

    // External-drive sinusoids (dashed grey)
    const rungPx = Math.abs(y1 - y0);
    ctx.save(); ctx.setLineDash([10,6]); ctx.strokeStyle="#c0c0c0"; ctx.lineWidth=1;
    drawSine(left, right, yScale((En[3]+En[2])/2), rungPx, 3);
    drawSine(left, right, yScale((En[2]+En[1])/2), rungPx, 3);
    drawSine(left, right, yScale((En[1]+En[0])/2), rungPx, 3);
    ctx.restore();

    // Optional green flash sine (on a specific rung)
    if (capsuleFlash !== null) {
      ctx.strokeStyle="green";
      ctx.lineWidth=3;
      drawSine(left, right, yScale((En[3]+En[2])/2), rungPx, 3);
      drawSine(left, right, yScale((En[2]+En[1])/2), rungPx, 3);
      drawSine(left, right, yScale((En[1]+En[0])/2), rungPx, 3);
    }



    // Leakage warning (during excite outcome)
    if (leakageFlash){
      const yLeak = (yScale(En[3]) + yScale(En[2])) / 2 + 20;
      const xLeak = right - 10;
      const text = "LEAKAGE!";
      ctx.save();
      ctx.font = "48px system-ui, sans-serif";
      ctx.textAlign = "right";
      const textWidth = ctx.measureText(text).width;
      const pad = 18;

      // 🟡 Yellow circular background (oval bubble)
      ctx.beginPath();
      ctx.roundRect(xLeak - textWidth - pad, yLeak - 38-10, textWidth + pad * 2, 60, 30);
      ctx.fillStyle = "rgba(255, 235, 59, 0.8)";  // soft yellow background
      ctx.strokeStyle = "rgba(255, 193, 7, 0.9)"; // deeper yellow border
      ctx.lineWidth = 3;
      ctx.fill();
      ctx.stroke();

      // 🔴 Text
      ctx.fillStyle = "#d32f2f";
      ctx.fillText(text, xLeak, yLeak);
      ctx.restore();
    }


    // Dots (blue @ |0|.., red @ |1|..)
    const xB=left+X_BLUE*(right-left), xR=left+X_RED*(right-left);
    ctx.fillStyle="#1f77b4"; drawDot(xB, yScale(En[state.levelBlue]), 22);
    ctx.fillStyle="#d62728"; drawDot(xR, yScale(En[state.levelRed]), 22);

    // Summary line under title
    summary.textContent =
      `α = ${state.alphaMHz.toFixed(0)} MHz · Drive = ${ghz(DRIVE)} · Pulse BW ≈ ${(SIGMA_F/1e6).toFixed(1)} MHz`;
  }

  function drawDot(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,2*Math.PI); ctx.fill(); }
  function drawArrowHead(x,y,angle){
    const len=12, w=8; ctx.save(); ctx.translate(x,y); ctx.rotate(angle);
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-w,len); ctx.lineTo(w,len); ctx.closePath(); ctx.fill(); ctx.restore();
  }
  function drawSine(x0,x1,yMid,ampPx,cycles){
    const N=220; ctx.beginPath();
    for(let i=0;i<=N;i++){
      const t=i/N, x=x0+t*(x1-x0), y=yMid + 0.5*ampPx*Math.sin(2*Math.PI*cycles*t);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  // ---------- Interaction ----------
  function excite(){
    if (state.busy) return;
    state.busy = true; alphaSlider.disabled=true; exciteBtn.disabled=true;

    // Brief highlight of driven bands
    draw(true,false);
    setTimeout(() => {
      const {fnn1} = levels(state.alphaMHz);
      const f01=fnn1[0], f12=fnn1[1];

      // Blue: 0→1 with Gaussian spectral selectivity
      const Pg = probGauss(DRIVE - f01);
      const doBlueUp = (Math.random() < Pg) && state.levelBlue < N_LADDER-1;

      // Red: 1→2 or 1→0, with √(n+1) matrix element scaling: 1→2 ~ √2, 1→0 ~ 1
      const wUp   = probGauss(DRIVE - f12) * Math.SQRT2 * (state.levelRed < N_LADDER-1 ? 1:0);
      const wDown = probGauss(DRIVE - f01) * 1.0       * (state.levelRed > 0 ? 1:0);
      const wTot = wUp + wDown;
      let doRedUp=false, doRedDown=false;
      if (wTot>0 && Math.random() < Math.min(1,wTot)){
        const r=Math.random(); doRedUp = r < (wUp/wTot); doRedDown = !doRedUp;
      }

      // Apply transition
      if (doBlueUp) state.levelBlue++;
      if (doRedUp) state.levelRed++;
      if (doRedDown) state.levelRed--;

      draw(null, doRedUp);  // flash "LEAKAGE!" if went 1→2

      // Hold result a moment, then bounce back to initial levels for repeatable demo
      setTimeout(()=>{
        if (doBlueUp) state.levelBlue--;
        if (doRedUp) state.levelRed--;
        if (doRedDown) state.levelRed++;
        draw();
        state.busy=false; alphaSlider.disabled=false; exciteBtn.disabled=false;
      }, 1200);
    }, 600);
  }

  alphaSlider.addEventListener('input', () => {
    state.alphaMHz = parseFloat(alphaSlider.value);
    alphaVal.textContent = alphaSlider.value;
    if (!state.busy) draw();
  });
  exciteBtn.addEventListener('click', excite);

  // ---------- Init ----------
  resizeCanvasToDisplaySize();
  alphaVal.textContent = state.alphaMHz.toFixed(0);
  draw();
  window.addEventListener('resize', draw);
})();
</script>

<footer>
  © 2025 Wen-Sen Lu. Licensed under
  <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a>.<br>
  “Anharmonic Ladder” visualization concept by Wen-Sen Lu — for educational and research use only.
</footer>
</body>
</html>
