<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="license" content="CC BY-NC-SA 4.0" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Why Superconducting Qubits need cryogenics</title>
<style>
  :root { --maxw: 980px; }

  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
         margin:0; background:#fff; color:#111; }

  /* Title + summary caption */
  h1{ text-align:center; font-size:26px; margin:16px 0 4px; }
  #summary{ text-align:center; font-size:18px; font-weight:600; margin:0 0 8px; }

  #wrap{ position:relative; padding:0 12px 8px; }

  canvas{
    width:100%; max-width: calc(var(--maxw) + 260px);
    aspect-ratio: 11/4; height:auto; display:block; margin:6px auto 4px;
  }

  /* ===== Controls ===== */
  /* 1) 讓整個控制列成為垂直置中的 flex 容器 */
#controls{
  background:#f8fafc; border:1px solid #e5e7eb; border-radius:12px;
  box-shadow:0 3px 10px rgba(0,0,0,.04);
  padding:12px 16px; max-width:calc(var(--maxw));
  margin:12px auto 10px;

  display:flex;              /* 新增 */
  flex-direction:column;     /* 新增：垂直排列 */
  align-items:center;        /* 新增：子項目水平置中 */
}

/* 2) 第一行維持置中，並讓它佔滿寬度以便與膠囊對齊 */
.row1{
  display:flex; justify-content:center; align-items:center;
  gap:28px; flex-wrap:wrap; margin-bottom:10px;
  width:100%;                /* 新增 */
}

/* 3) 膠囊本體：全寬但限制最大寬，靠 margin:auto 置中 */
.feedbackBox{
  background:#fff; border:1px solid #e5e7eb; border-radius:12px;
  box-shadow:0 2px 6px rgba(0,0,0,.03);
  padding:10px 12px;

  width:50%;                /* 新增：佔可用寬 */
  max-width:820px;           /* 你想要的最大寬度 */
  margin:8px auto 0;         /* 置中 */
  display: flex;
  flex-direction: column;
  align-items: center;     /* ✅ 水平置中膠囊裡的所有項目 */
  justify-content: center; /* ✅ 垂直置中（若有多行） */
  text-align: center;      /* ✅ 讓文字也置中 */
}

  .toggleRow{ display:flex; align-items:center; gap:10px; justify-content: center; /* ✅ 讓 checkbox 與文字整行置中 */
  text-align: center;}
  .rfbRow{ display:flex; align-items:center; gap:10px; justify-content: center; /* ✅ 將滑桿置中對齊 */
  text-align: center;}
  .rfbRow input[type="range"]{ width:260px; }

  /* 禁用時的視覺淡化 */
  #rfb:disabled, #rfb:disabled + #rfbVal{ opacity:.45; filter:grayscale(20%); }

  @media (max-width:680px){
    .group input[type="range"]{ width:160px; }
    .rfbRow input[type="range"]{ width:200px; }
  }

  /* Legend under controls */
  .legend{
    max-width: calc(var(--maxw)); margin:6px auto 10px;
    background:rgba(255,255,255,0.95); border:1px solid #ddd; border-radius:6px;
    padding:8px 12px; font-size:16px; box-shadow:0 1px 2px rgba(0,0,0,.05);
  }
  .legend .row{ display:flex; align-items:flex-start; flex-wrap:wrap; gap:8px; margin:4px 0; white-space:normal; }
  .dot{ width:14px; height:14px; border-radius:50%; display:inline-block; }
  .dot.blue{ background:#1f77b4; }
  .dot.red{ background:#d62728; }
  .swatch{ width:24px; height:3px; background:#c0c0c0; display:inline-block; }

footer a:hover { text-decoration: underline; }
</style>
</head>
<body>
  <h1>Why Superconducting Qubits need cryogenicsy</h1>
  <div id="summary">T = 0.030 K · T₁ = 10 µs · R_fb = 0.8 MHz · Feedback: ON · P₁<sup>(fb)</sup> ≈ 0.89</div>

  <div id="wrap"><canvas id="ladder"></canvas></div>

  <!-- Controls -->
  <div id="controls">
    <!-- 第 1 行：T、T1 -->
    <div class="row1">
      <div class="group">
        <label for="temp">T (K)</label>
        <input id="temp" type="range" min="0.005" max="0.9" step="0.005" value="0.030">
        <output id="tempVal">0.030</output>
      </div>

      <div class="group">
        <label for="t1">T₁ (µs)</label>
        <input id="t1" type="range" min="5" max="200" step="5" value="100">
        <output id="t1Val">100</output>
      </div>
    </div>

    <!-- 第 2 個膠囊：第 3 行(checkbox) + 第 4 行(R_fb) -->
    <div class="feedbackBox">
      <div class="toggleRow">
        <input id="fbOn" type="checkbox" checked>
        <label for="fbOn"><b>Feedback ON</b>（red stabilize |1⟩，blue reset to |0⟩）</label>
      </div>
      <div class="rfbRow">
        <label for="rfb">R_fb (MHz)</label>
        <input id="rfb" type="range" min="0" max="10" step="1" value="1">
        <output id="rfbVal">1</output>
      </div>
    </div>
  </div>

  <div class="legend" id="legend">
    <div class="row"><span class="dot blue"></span> Blue: thermal (Boltzmann over |0⟩..|3⟩) + <em>optional</em> active reset to |0⟩</div>
    <div class="row"><span class="dot red"></span> Red: stabilized at |1⟩ via the same active reset</div>
    <div class="row"><span class="swatch"></span>&nbsp;Energy levels (f₀₁ = 5 GHz, α = −0.2 GHz)</div>
    <div class="row"><span style="width:14px;height:14px;background:rgba(255,165,0,0.35);border:1px solid rgba(255,140,0,0.7);display:inline-block;"></span>&nbsp;kBT overlay</div>
  </div>

<script>
(() => {
  // -------- physics constants & ladder -----------
  const F01=5e9, ALPHA=-0.2e9, N_LADDER=4;
  const kB=1.380649e-23, h=6.62607015e-34;

  // DOM
  const canvas=document.getElementById('ladder'), ctx=canvas.getContext('2d');
  const tempSlider=document.getElementById('temp'), t1Slider=document.getElementById('t1');
  const rfbSlider=document.getElementById('rfb'), fbOn=document.getElementById('fbOn');
  const tempVal=document.getElementById('tempVal'), t1Val=document.getElementById('t1Val');
  const rfbVal=document.getElementById('rfbVal'), summary=document.getElementById('summary');

  function resizeCanvasToDisplaySize(){
    const dpr=window.devicePixelRatio||1, rect=canvas.getBoundingClientRect();
    const needW=Math.round(rect.width*dpr), needH=Math.round(rect.height*dpr);
    if(canvas.width!==needW||canvas.height!==needH){ canvas.width=needW; canvas.height=needH; }
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  function computeLayout(){
    const rect=canvas.getBoundingClientRect(), cssW=rect.width, cssH=rect.height;
    const left=60, right=cssW-160, top=90, bottom=cssH-20;
    return {left,right,top,bottom, X_BLUE:0.30, X_RED:0.70};
  }

  const state={ T:parseFloat(tempSlider.value), T1_us:parseFloat(t1Slider.value),
                Rfb_MHz:parseFloat(rfbSlider.value), FB:fbOn.checked,
                lastAnim:0, blueTrail:[], redTrail:[] };
  const TRAIL_LEN=24, TRAIL_ALPHA_MAX=0.35, DOT_RADIUS=22;

  function computeLevels_J(){ const En=[]; for(let n=0;n<N_LADDER;n++){ const f=F01*n+0.5*ALPHA*n*(n-1); En.push(h*f);} return En; }
  function nth(T){ const x=(h*F01)/(kB*T); if(!isFinite(x)||x>100) return 0; return 1/(Math.exp(x)-1); }
  function boltzmannP(T){ const En=computeLevels_J(), E0=En[0], Te=Math.max(T,1e-6);
    const w=En.map(E=>Math.exp(-(E-E0)/(kB*Te))); const Z=w.reduce((a,b)=>a+b,0); return w.map(v=>v/Z); }
  function clear(){ ctx.fillStyle="#fff"; ctx.fillRect(0,0,canvas.width,canvas.height); }

  function drawTemperatureOverlay(T,left,right,yScale,EnHz){
    const f_kT=(kB*T)/h, yBase=yScale(EnHz[0]), yTop=yScale(EnHz[0]+f_kT);
    const rectTop=Math.min(yBase,yTop), rectH=Math.abs(yTop-yBase);
    ctx.save(); ctx.fillStyle="rgba(255,165,0,0.22)"; ctx.strokeStyle="rgba(255,140,0,0.7)"; ctx.lineWidth=1.5;
    ctx.fillRect(left,rectTop,(right-left),rectH);
    ctx.fillStyle="rgba(180,80,0,0.9)"; ctx.font="16px system-ui,sans-serif"; ctx.textAlign="left";
    ctx.fillText(`thermal energy ≈ ${(f_kT*6.626E-34/kB*1e3).toFixed(0)} mK`, left, rectTop-8);
    ctx.restore();
  }

  function drawTrail(trail,color,xPos,yScale,EnHz){
    for(let i=0;i<trail.length;i++){
      const lvl=trail[i], tFrac=(i+1)/trail.length, alpha=tFrac*TRAIL_ALPHA_MAX, r=DOT_RADIUS*(0.6+0.4*tFrac);
      ctx.save(); ctx.globalAlpha=alpha; ctx.fillStyle=color; ctx.beginPath(); ctx.arc(xPos,yScale(EnHz[lvl]),r,0,2*Math.PI); ctx.fill(); ctx.restore();
    }
  }

  function draw(T,T1_us,Rfb_MHz,FB,blueLevel,redLevel,P1fb){
    resizeCanvasToDisplaySize();
    const {left,right,top,bottom,X_BLUE,X_RED}=computeLayout();
    clear();

    const EnJ=computeLevels_J(), EnHz=EnJ.map(E=>E/h);
    const yMin=EnHz[0]-0.3e9, yMax=EnHz[N_LADDER-1]+1.0e9;
    const yScale=y=>bottom-(y-yMin)*((bottom-top)/(yMax-yMin));

    ctx.strokeStyle="#000"; ctx.lineWidth=3; ctx.fillStyle="#000"; ctx.font="32px system-ui,sans-serif";
    for(let i=0;i<N_LADDER;i++){ const y=yScale(EnHz[i]); ctx.beginPath(); ctx.moveTo(left,y); ctx.lineTo(right,y); ctx.stroke(); ctx.fillText("|"+i+">", right+10, y+11); }

    drawTemperatureOverlay(T,left,right,yScale,EnHz);

  // --- Label with capsule background ---
  let msg, capsuleColor;
  if (!FB) {
    msg = "No feedback, no hustle — 1 state is on Paid Time Off (PTO) 😴";
    capsuleColor = "rgba(200,200,200,0.7)";   // 淺灰底
  } else {
    msg = (T < 0.05) ? "Qubit chillin’ — stable and ready to compute, sir! 🧊"
        : (T < 0.2)  ? "Small thermal kick — warmish, not catastrophic, but we wouldn’t compute like this 👀."
        : (T < 0.5)  ? "Thermal chaos creeping in — qubits kinda vibing too hard 🔥"
        : "Bruh, it’s basically a hot resistor now, coherence left the chat 💀";

    capsuleColor =
      (T < 0.05) ? "rgba(102, 204, 153, 0.85)"    // 🟢 冷
    : (T < 0.2)  ? "rgba(255, 221, 87, 0.85)"     // 🟡 微暖
    : (T < 0.5)  ? "rgba(255, 170, 66, 0.85)"     // 🟠 熱混合
    :              "rgba(240, 90, 90, 0.85)";     // 🔴 熱崩潰
  }

  ctx.save();
  ctx.font = "18px system-ui, sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  const xMid = (left + right) / 2;
  const yMsg = top - 30;
  const textWidth = ctx.measureText(msg).width;
  const padX = 14, padY = 8;

  // 膠囊背景
  ctx.fillStyle = capsuleColor;
  ctx.strokeStyle = "rgba(0,0,0,0.15)";
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.roundRect(xMid - textWidth/2 - padX, yMsg - 14, textWidth + padX*2, 28, 12);
  ctx.fill();
  ctx.stroke();

  // 文字
  ctx.fillStyle = "#222";
  ctx.fillText(msg, xMid, yMsg);
  ctx.restore();


    const y0=yScale(EnHz[0]), y1=yScale(EnHz[1]);
    ctx.save(); ctx.setLineDash([3,3]); ctx.lineWidth=1; ctx.strokeStyle="#000";
    const m=6, boxTop=y1-0.12*Math.abs(y1-y0), boxBot=y0+0.12*Math.abs(y1-y0);
    ctx.strokeRect(left-m,boxTop,(right-left)+2*m,boxBot-boxTop);
    ctx.fillStyle="#000"; ctx.font="16px system-ui,sans-serif"; ctx.fillText("Computational space", right-160, boxTop+30);
    ctx.restore();

    const w=right-left, xB=left+X_BLUE*w, xR=left+X_RED*w;
    drawTrail(state.blueTrail,"#1f77b4",xB,yScale,EnHz);
    drawTrail(state.redTrail,"#d62728",xR,yScale,EnHz);
    ctx.fillStyle="#1f77b4"; ctx.beginPath(); ctx.arc(xB,yScale(EnHz[blueLevel]),22,0,2*Math.PI); ctx.fill();
    ctx.fillStyle="#d62728"; ctx.beginPath(); ctx.arc(xR,yScale(EnHz[redLevel]),22,0,2*Math.PI); ctx.fill();

    summary.textContent=`T = ${T.toFixed(3)} K · T₁ = ${T1_us.toFixed(0)} µs · R_fb = ${Rfb_MHz.toFixed(1)} MHz · Feedback: ${FB?'ON':'OFF'} · P₁^(fb) ≈ ${P1fb.toFixed(2)}`;
  }

  function randomLevel(P){ const r=Math.random(); let c=0; for(let i=0;i<P.length;i++){ c+=P[i]; if(r<c) return i; } return P.length-1; }

  function redLevelWithFeedbackRates(T,T1_us,Rfb_MHz,FB){
    const Pth=boltzmannP(T);
    if(!FB) return {level: randomLevel(Pth), P1: Pth[1]||0};
    const Gamma1=1/(T1_us*1e-6), nthT=nth(T);
    const Gamma_up=Gamma1*nthT, Gamma_down=Gamma1*(1+nthT), Rfb=Rfb_MHz*1e6;
    const P1_ss=(Rfb+Gamma_up)/(Rfb+Gamma_up+Gamma_down);
    if(Math.random()<P1_ss) return {level:1, P1:P1_ss};
    return {level: randomLevel(Pth), P1:P1_ss};
  }

  function blueLevelWithReset(T,T1_us,Rfb_MHz,FB){
    const Pth=boltzmannP(T); let lvl=randomLevel(Pth);
    if(!FB) return lvl;
    const Gamma1=1/(T1_us*1e-6), nthT=nth(T);
    const Gamma_up=Gamma1*nthT, Gamma_down=Gamma1*(1+nthT), Rfb=Rfb_MHz*1e6;
    const qReset=Rfb/(Rfb+Gamma_down+Gamma_up+1e-12);
    if(lvl>0 && Math.random()<qReset) lvl=0;
    return lvl;
  }

  function loop(tNow){
    if(tNow-state.lastAnim>50){
      const {T,T1_us,Rfb_MHz,FB}=state;
      const blueLevel=blueLevelWithReset(T,T1_us,Rfb_MHz,FB);
      const redObj=redLevelWithFeedbackRates(T,T1_us,Rfb_MHz,FB);
      const redLevel=redObj.level;
      state.blueTrail.push(blueLevel); state.redTrail.push(redLevel);
      if(state.blueTrail.length>24) state.blueTrail.shift();
      if(state.redTrail.length>24) state.redTrail.shift();
      draw(T,T1_us,Rfb_MHz,FB,blueLevel,redLevel,redObj.P1);
      state.lastAnim=tNow;
    }
    requestAnimationFrame(loop);
  }

  // UI
  tempSlider.addEventListener('input', ()=>{ state.T=parseFloat(tempSlider.value); tempVal.textContent=state.T.toFixed(3); });
  t1Slider.addEventListener('input', ()=>{ state.T1_us=parseFloat(t1Slider.value); t1Val.textContent=state.T1_us.toFixed(0); });
  rfbSlider.addEventListener('input', ()=>{ state.Rfb_MHz=parseFloat(rfbSlider.value); rfbVal.textContent=state.Rfb_MHz.toFixed(1); });
  fbOn.addEventListener('change', ()=>{
    state.FB=fbOn.checked;
    rfbSlider.disabled=!fbOn.checked;
    rfbVal.textContent=state.Rfb_MHz.toFixed(1);
  });

  // init
  resizeCanvasToDisplaySize();
  tempVal.textContent=state.T.toFixed(3);
  t1Val.textContent=state.T1_us.toFixed(0);
  rfbVal.textContent=state.Rfb_MHz.toFixed(1);
  rfbSlider.disabled=!fbOn.checked;

  const Pblue0=boltzmannP(state.T), blue0=randomLevel(Pblue0), red0=1;
  state.blueTrail=Array(4).fill(blue0); state.redTrail=Array(4).fill(red0);

  draw(state.T,state.T1_us,state.Rfb_MHz,state.FB,blue0,red0,1.0);
  requestAnimationFrame(loop);
  window.addEventListener('resize', resizeCanvasToDisplaySize);
})();
</script>

<footer style="
  text-align:center;
  font-size:14px;
  color:#555;
  margin:24px 0 10px;
  line-height:1.4;
">
  © 2025 Wen-Sen Lu. Licensed under 
  <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/"
     target="_blank"
     rel="noopener noreferrer"
     style="color:#007acc; text-decoration:none; font-weight:500;">
     CC BY-NC-SA 4.0
  </a>.<br>
  “Why we need cryogenics for Superconducting Qubits?” visualization concept by Wen-Sen Lu — for educational and research use only.
</footer>

</body>
</html>
