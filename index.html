<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>(An)Harmonic Ladder — α slider + Excite</title>
<style>
  :root { --maxw: 980px; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin:0; background:#fff; color:#111; }
  header { padding: 12px 16px; display:flex; gap:16px; align-items:center; position:sticky; top:0; background:#fff; z-index:10; }
  #alphaVal { width:70px; text-align:right; font-variant-numeric: tabular-nums; }
  #excite { background:#e74c3c; color:#fff; border:none; padding:8px 16px; border-radius:6px; cursor:pointer; font-weight:600; }
  #excite:disabled { opacity:.6; cursor:default; }
  #wrap { padding: 0 12px 6px; position: relative; }
  canvas { width:100%; max-width: calc(var(--maxw) + 260px); height:auto; display:block; margin:4px 16px 8px; }
  .legend { position:absolute; left:28px; background:rgba(255,255,255,0.95); border:1px solid #ddd; border-radius:6px; padding:8px 12px; font-size:16px; box-shadow:0 1px 2px rgba(0,0,0,.05); }
  .legend .row { display:flex; align-items:center; gap:8px; margin:4px 0; white-space:nowrap; }
  .dot { width:14px; height:14px; border-radius:50%; display:inline-block; }
  .dot.blue { background:#1f77b4; }
  .dot.red  { background:#d62728; }
  .swatch { width:24px; height:3px; background:#c0c0c0; display:inline-block; }
  footer {
  text-align: left;
  padding-left: 20px;   /* optional indent */
  color: #111;
  margin: 4px 0 8px;
  font-size: 22px;
  font-weight: 600;
}
</style>
</head>
<body>
<header>
  <label>α (MHz)
    <input id="alpha" type="range" min="-800" max="800" step="50" value="-200">
  </label>
  <output id="alphaVal">-200</output>
  <button id="excite">Excite</button>
</header>

<div id="wrap">
  <div class="legend" id="legend">
    <div class="row"><span class="dot blue"></span> if Qubit in Ground state</div>
    <div class="row"><span class="dot red"></span> if Qubit in Excited state</div>
    <div class="row"><span class="swatch"></span>&nbsp;5&nbsp;GHz external drive</div>
  </div>
  <canvas id="ladder"></canvas>
</div>

<footer id="caption">(An)Harmonic ladder, α = -200 MHz</footer>

<script>
(() => {
  // --------- Parameters ----------
  const F01 = 5e9;            // Hz
  const N_LADDER = 4;         // |0>..|3>
  const X_GROUND = 0.30;      // fraction of ladder width
  const X_EXCITED = 0.70;

  // Drive & probability model (Gaussian π-pulse spectrum)
  const DRIVE = 5e9;          // Hz
  const SIGMA_F = 22.7e6;     // Hz (≈ 1/(2π*7ns)), matches Python Gaussian width

  // Dots
  const DOT_R = 24;
  const OPEN_R = 23;

  // Canvas & UI
  const canvas = document.getElementById('ladder');
  const ctx = canvas.getContext('2d');
  const alphaSlider = document.getElementById('alpha');
  const alphaVal = document.getElementById('alphaVal');
  const exciteBtn = document.getElementById('excite');
  const caption = document.getElementById('caption');
  const legend = document.getElementById('legend');

  // Layout (ladder region)
  const left  = 60;
  const right = 60 + 980;   // ladder width
  const top   = 90;
  const bottom= 460;        // leaves room for title
  const xArrow= right + 80; // fixed X for vertical transition arrows

  const state = {
    busy: false,
    alphaMHz: parseFloat(alphaSlider.value),
    levelG: 0,
    levelE: 1,
  };

  // Retina sizing
  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    // Use computed CSS size
    const cssW = canvas.clientWidth || 1320;
    const cssH = Math.round(cssW * (480/1320)); // keep a nice aspect; adjust to taste
    canvas.style.height = cssH + 'px';
    const rect = canvas.getBoundingClientRect();
    const w = Math.round(rect.width * dpr);
    const h = Math.round(rect.height * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; canvas.height = h;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
  }

  function computeLevels(alphaMHz, N) {
    const alpha = alphaMHz * 1e6;
    const w01 = 2*Math.PI*F01;
    const K   = 2*Math.PI*alpha;
    const En = [], fnn1 = [];
    for (let n=0;n<N;n++) {
      En.push((w01*n + 0.5*K*n*(n-1)) / (2*Math.PI)); // Hz
    }
    for (let n=0;n<N-1;n++) {
      fnn1.push((w01 + K*n) / (2*Math.PI)); // Hz
    }
    return { En, fnn1 };
  }

  function gaussianPulseProb(detuneHz){
    const x = detuneHz / SIGMA_F;
    return Math.exp(-0.5 * x * x);
  }

  function formatGHz(fHz) { return (fHz/1e9).toFixed(2)+"GHz"; }

  function clear() {
    ctx.fillStyle = "#fff";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  function draw(alphaMHz, levelG, levelE, flashLevel = null) {
    clear();
    const { En, fnn1 } = computeLevels(alphaMHz, N_LADDER);
    const yMin = En[0] - 0.3e9;
    const yMax = En[Math.min(N_LADDER-1,4)] + 1e9;
    const yScale = (y) => bottom - (y - yMin) * ((bottom - top)/(yMax - yMin));

    // Rung height in pixels = |E1 - E0| mapped to pixels
    const rungHeightPx = Math.abs(yScale(En[0]) - yScale(En[1]));

    // Rungs + |n> labels (large)
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 3;
    ctx.fillStyle = "#000";
    ctx.font = "36px system-ui, sans-serif";
    for (let i=0;i<N_LADDER;i++) {
      const y = yScale(En[i]);
      ctx.beginPath();
      ctx.moveTo(left, y);
      ctx.lineTo(right, y);
      ctx.stroke();
      ctx.fillText("|"+i+">", right + 10, y + 12);
    }

    // Vertical dashed arrows (gray) + labels
    ctx.save();
    ctx.setLineDash([6,5]);
    ctx.strokeStyle="#c0c0c0";
    ctx.lineWidth=2;
    ctx.fillStyle="#c0c0c0";
    ctx.font = "24px system-ui, sans-serif";
    for (let i=0;i<N_LADDER-1;i++) {
      const yA = yScale(En[i]), yB = yScale(En[i+1]);
      // dashed line
      ctx.beginPath();
      ctx.moveTo(xArrow, yA);
      ctx.lineTo(xArrow, yB);
      ctx.stroke();
      // arrow heads (up at lower rung, down at upper rung)
      ctx.fillStyle = "#c0c0c0";
      drawArrowHead(xArrow, yA, 0);
      drawArrowHead(xArrow, yB, Math.PI);

      // label
      const label = "f_" + i + (i + 1) + "=" + formatGHz(fnn1[i]);
      const lx = xArrow + 18;
      const ly = (yA + yB) / 2 + 10;

      // base grey label
      ctx.fillStyle = "#c0c0c0";
      ctx.fillText(label, lx, ly);

      // optional green overdraw (safe scoped)
      if (flashLevel !== null) {
        const shouldHighlight = (i === 0) || (alphaMHz === 0 && [1,2].includes(i));
        if (shouldHighlight) {
          ctx.save();
          ctx.fillStyle = "green";
          ctx.fillText(label, lx, ly);
          ctx.restore();
        }
      }
    }
    ctx.restore();

    // External-drive sine waves (silver dashed), dy = 1× rung height
    ctx.save();
    ctx.strokeStyle = "#c0c0c0";
    ctx.lineWidth = 3;
    ctx.setLineDash([10, 6]);
    drawSineOnBand(left, right, yScale( (En[0]+En[1])/2 ), rungHeightPx, 3);
    drawSineOnBand(left, right, yScale( (En[1]+En[2])/2 ), rungHeightPx, 3);
    ctx.restore();

    // Optional green flash sine on both bands
    if (flashLevel !== null) {
      ctx.save();
      ctx.strokeStyle="green";
      ctx.lineWidth=3;
      drawSineOnBand(left, right, yScale((En[0]+En[1])/2), rungHeightPx, 3);
      drawSineOnBand(left, right, yScale((En[1]+En[2])/2), rungHeightPx, 3);
      ctx.restore();
    }

    // Dots positions
    const w = right - left;
    const xG = left + X_GROUND*w;
    const xE = left + X_EXCITED*w;

    // Static dashed open circles at baseline |0> (blue) and |1> (red)
    ctx.save();
    ctx.setLineDash([5, 3]);
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#1f77b4";
    drawOpenCircle(xG, yScale(En[0]), OPEN_R);
    ctx.strokeStyle = "#d62728";
    drawOpenCircle(xE, yScale(En[1]), OPEN_R);
    ctx.restore();

    // Filled dots (current state)
    ctx.fillStyle="#1f77b4";
    drawDot(xG, yScale(En[Math.max(0,Math.min(N_LADDER-1, levelG))]), DOT_R);
    ctx.fillStyle="#d62728";
    drawDot(xE, yScale(En[Math.max(0,Math.min(N_LADDER-1, levelE))]), DOT_R);

    // Title
    caption.textContent = `(An)Harmonic ladder, α = ${alphaMHz.toFixed(0)} MHz`;

    // Legend above |3>
    const yTopRung = yScale(En[3]);
    const legendBox = legend.getBoundingClientRect();
    const canvasBox = canvas.getBoundingClientRect();
    const desiredTopPx = Math.max(12, (yTopRung - (legendBox.height - 20)));
    const canvasTop = canvasBox.top + window.scrollY;
    legend.style.top = `${canvasTop + desiredTopPx}px`;
    legend.style.left = `28px`;
  }

  function drawDot(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,2*Math.PI); ctx.fill(); }
  function drawOpenCircle(x, y, r){ ctx.beginPath(); ctx.arc(x, y, r, 0, 2*Math.PI); ctx.stroke(); }

  function drawArrowHead(x, y, angle) {
    const len = 12, width = 8;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.moveTo(0, 0);              // tip
    ctx.lineTo(-width, len);
    ctx.lineTo(width, len);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // Sine wave of amplitude "dy" (pixels) centered on yMidPx
  function drawSineOnBand(x0, x1, yMidPx, dy, cycles) {
    const N = 220;
    ctx.beginPath();
    for (let i=0;i<=N;i++) {
      const t = i/N;
      const x = x0 + t*(x1-x0);
      const y = yMidPx + dy * Math.sin(2*Math.PI*cycles*t) * 0.5; // 0.5 keeps within band
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  function exciteOnce(){
    if (state.busy) return;
    state.busy = true; alphaSlider.disabled=true; exciteBtn.disabled=true;

    // Flash green on both bands briefly
    draw(state.alphaMHz, state.levelG, state.levelE, 2);
    setTimeout(() => {
      const { fnn1 } = computeLevels(state.alphaMHz, N_LADDER);
      const f01 = fnn1[0], f12 = fnn1[1];

      // Probabilities from Gaussian spectral width (close to QuTiP pulse)
      const P_ground  = gaussianPulseProb(DRIVE - f01);             // |0>→|1|
      const P_excited = gaussianPulseProb(DRIVE - f12) * Math.min(1, Math.SQRT2); // |1>→|2|

      const canRaiseG = state.levelG < (N_LADDER-1);
      const canRaiseE = state.levelE < (N_LADDER-1);
      const doG = canRaiseG && (Math.random() < P_ground);
      const doE = canRaiseE && (Math.random() < P_excited);

      if (doG) state.levelG += 1;
      if (doE) state.levelE += 1;

      draw(state.alphaMHz, state.levelG, state.levelE);

      // Hold excited state momentarily, then return
      setTimeout(() => {
        if (doG) state.levelG -= 1;
        if (doE) state.levelE -= 1;
        draw(state.alphaMHz, state.levelG, state.levelE);
        state.busy=false; alphaSlider.disabled=false; exciteBtn.disabled=false;
      }, 1600);
    }, 800);
  }

  // UI wiring (with resize-aware drawing)
  function redraw() { resizeCanvas(); draw(state.alphaMHz, state.levelG, state.levelE); }
  alphaSlider.addEventListener('input', () => {
    state.alphaMHz = parseFloat(alphaSlider.value);
    alphaVal.textContent = alphaSlider.value;
    if (!state.busy) redraw();
  });
  exciteBtn.addEventListener('click', exciteOnce);

  // Initial render & resize handling
  alphaVal.textContent = alphaSlider.value;
  window.addEventListener('resize', redraw, { passive: true });
  redraw();
})();
</script>
</body>
</html>
